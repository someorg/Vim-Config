# https://raw.github.com/jb55/snipmate-snippets/master/snippets/haskell.snippets

snippet lang
	{-# LANGUAGE ${1:OverloadedStrings} #-}
snippet info
	-- |
	-- Module      :  ${1:Module.Namespace}
	-- Copyright   :  ${2:Author} ${3:2011-2012}
	-- License     :  ${4:BSD3}
	-- 
	-- Maintainer  :  ${5:email@something.com}
	-- Stability   :  ${6:experimental}
	-- Portability :  ${7:unknown}
	--
	-- ${8:Description}
	--
snippet inst
	instance ${1:Class} ${2:Instance} where
		${3}
snippet type
	type ${1:Type} = ${2:Type}
snippet class
	class ${1:Class} a where
		${2}

# https://raw.github.com/laughedelic/dotvim/master/snippets/haskell.snippets

snippet u undefined
	undefined
snippet if if ... then ... else ...
	if ${1:condition}
	   then ${2:expression}
	   else ${3:expression}
snippet case case ... of
	case ${1:expression} of
		 ${2:pattern} -> ${3:expression}
		 ${4:otherwise} -> ${5:expression}
snippet :: Type signature
	${1:name} :: ${2:Type} -> ${3:Type}
snippet => Type constraint
	(${1:Class} ${2:type var}) => ${3:$2}
snippet def Function definition
	${1:name} :: ${2:Type} -> ${3:Type}
	$1 ${4:pattern} = ${5:undefined}
snippet def[] Function definition for list patterns
	${1:name} :: ${2:[Type]} -> ${3:Type}
	$1 [] = ${3:undefined}
	$1 ${4:(x:xs)} = ${5:undefined}
snippet = Function clause
	${1:name} ${2:pattern} = ${3:undefined}
snippet =2 Function clauses
	${1:name} ${2:pattern} = ${3:undefined}
	$1 ${4:pattern} = ${5:undefined}
snippet =3 Function clauses
	${1:name} ${2:pattern} = ${3:undefined}
	$1 ${4:pattern} = ${5:undefined}
	$1 ${6:pattern} = ${7:undefined}
snippet | Guard
	| ${1:predicate} = ${2:undefined}
snippet \ Lambda expression
	\ ${1:pattern} -> ${2:expression}
snippet [|] List comprehension	
	[ ${3:foo }$1 | ${1:x} <- ${2:xs} ]
snippet let Let ... in ...	
	let ${1:name} = ${2:expression}
	in ${3:expression}	
